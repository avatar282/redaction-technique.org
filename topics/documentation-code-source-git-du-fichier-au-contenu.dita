<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA 1.2 Topic//EN"
"/usr/share/dita-ot/dtd/technicalContent/dtd/topic.dtd">
<topic id="git-du-fichier-au-contenu">
  <title>Git&#160;: du fichier au contenu</title>
  <body>
    <p>
      Vous êtes habitué à manipuler des fichiers&#160;? Git vous invite à penser
      autrement. Avantage&#160;: vous avez une maîtrise beaucoup plus grande de votre
      contenu.
    </p>
    <p>
      Qu'est-ce qu'un fichier&#160;? Pour vous, un contenu, image, texte, feuille de
      calcul ou autre, identifié par un nom. Pour votre système d'exploitation,
      une suite de bits sur le disque dur à laquelle sont associés un nom de
      fichier et un chemin de répertoires. Si vous souhaitez gérer votre projet
      en termes de fichiers sous Git, vous allez au-devant de maintes
      difficultés. Si vous pensez plutôt en termes de contenu, tout devient
      beaucoup plus simple.
    </p>
    <p>
      Si vous donnez un fichier à Git, il le scinde directement en deux choses&#160;:
    </p>
    <ul>
      <li>
        <p>
          un contenu (suite de bits, ou <i>blob</i>),
        </p>
      </li>
      <li>
        <p>
          un arbre (lien entre le nom de fichier et le contenu).
        </p>
      </li>
    </ul>
    <p>
      Il le stocke ensuite dans l'une des deux zones suivantes&#160;:
    </p>
    <ul>
      <li>
        <p>
          l'index (zone temporaire),
        </p>
      </li>
      <li>
        <p>
          la base de données d'objets (zone persistante).
        </p>
      </li>
    </ul>
    <p>
      Lorsque vous ajoutez un fichier (<i>git add &lt;fichier&gt;</i>)&#160;:
    </p>
    <ul>
      <li>
        <p>
          l'arbre est placé dans l'index,
        </p>
      </li>
      <li>
        <p>
          le contenu est placé dans la base d'objets.
        </p>
      </li>
    </ul>
    <p>
      Lorsque vous <i>commitez</i> un fichier (<i>git commit</i>)&#160;:
    </p>
    <ul>
      <li>
        <p>
          l'arbre est placé dans la base d'objets.
        </p>
      </li>
    </ul>
    <p>
      Git ne compare jamais deux fichiers entre eux. Il compare leur résumé, qui
      est un nombre unique calculé à partir de leur contenu.  Si le résumé de
      deux fichiers est identique, le contenu de ces fichiers est indentique (au
      bit près).
    </p>
    <p>
      L'historique de votre projet n'est pas forcément linéaire&#160;: vous pouvez
      lui faire suivre plusieurs routes parallèles, les branches.
    </p>
    <p>
      Vous ne pouvez créer des branches qu'à partir d'un <i>commit</i>. Il faut
      voir les <i>commits</i> comme des ronds-points (la route étant
      l'historique de votre projet) à partir desquels vous pouvez, si vous le
      souhaitez, prendre une autre direction dans votre projet.
    </p>
    <p>
      Si vous créez une branche, disons <i>test</i>, alors que des modifications
      de votre espace de travail ne sont pas <i>commitées</i> dans votre branche
      <i>master</i>, les modifications que vous effectuerez s'appliqueront aux
      fichiers non <i>commités</i> de votre espace de travail. Si vous faites
      une erreur, vous ne pourrez pas retrouver le <i>statu quo ante</i> de vos
      fichiers en revenant à la branche <i>master</i>.
    </p>
    <p>
      Si vous voulez enregistrer votre travail au fil de l'eau afin de pouvoir
      revenir à tout moment à un état antérieur, il vous faut donc
      <i>committer</i> régulièrement et sauvegarder votre espace de travail,
      répertoire <i>.git</i> y compris, par exemple <i>via</i> rsync. Lorsque
      vous déciderez de partager votre travail, vous pourrez déplacer, fusionner
      ou supprimer vos <i>commits</i> avant de les envoyer sous forme de patchs
      ou de les déposer sur un dépôt central.
    </p>
  </body>
</topic>
