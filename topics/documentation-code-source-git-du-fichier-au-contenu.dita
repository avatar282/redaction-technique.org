<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA 1.2 Topic//EN"
"/usr/share/dita-ot/dtd/technicalContent/dtd/topic.dtd">
<topic id="git-du-fichier-au-contenu">
  <title>Git : du fichier au contenu</title>
  <body>
  <p>
    Vous êtes habitué à manipuler des fichiers ? Git vous invite à
    penser autrement. Avantage : vous avez une maîtrise beaucoup plus
    grande de votre contenu.
  </p>
  <p>
    Qu'est-ce qu'un fichier ? Pour vous, un contenu, image, texte,
    feuille de calcul ou autre, identifié par un nom. Pour votre système
    d'exploitation, une suite de bits sur le disque dur à laquelle sont
    associés un nom de fichier et un chemin de répertoires. Si vous
    souhaitez gérer votre projet en termes de fichiers sous Git, vous
    allez au-devant de maintes difficultés. Si vous pensez plutôt en
    termes de contenu, tout devient beaucoup plus simple.
  </p>
  <p>
    Si vous donnez un fichier à Git, il le scinde directement en deux
    choses :
  </p>
  <ul>
    <li>
      <p>
        un contenu (suite de bits, ou <b>blob</b>),
      </p>
    </li>
    <li>
      <p>
        un arbre (lien entre le nom de fichier et le contenu).
      </p>
    </li>
  </ul>
  <p>
    Il le stocke ensuite dans l'une des deux zones suivantes :
  </p>
  <ul>
    <li>
      <p>
        l'index (zone temporaire),
      </p>
    </li>
    <li>
      <p>
        la base de données d'objets (zone persistante).
      </p>
    </li>
  </ul>
  <p>
    Lorsque vous ajoutez un fichier (<b>git add
    &lt;fichier&gt;</b>) :
  </p>
  <ul>
    <li>
      <p>
        l'arbre est placé dans l'index,
      </p>
    </li>
    <li>
      <p>
        le contenu est placé dans la base d'objets.
      </p>
    </li>
  </ul>
  <p>
    Lorsque vous <b>commitez</b> un fichier (<b>git
    commit</b>) :
  </p>
  <ul>
    <li>
      <p>
        l'arbre est placé dans la base d'objets.
      </p>
    </li>
  </ul>
  <p>
    Git ne compare jamais deux fichiers entre eux. Il compare leur
    résumé, qui est un nombre unique calculé à partir de leur contenu.
    Si le résumé de deux fichiers est identique, le contenu de ces
    fichiers est indentique (au bit près).
  </p>
  <p>
    L'historique de votre projet n'est pas forcément linéaire : vous
    pouvez lui faire suivre plusieurs routes parallèles, les branches.
  </p>
  <p>
    Vous ne pouvez créer des branches qu'à partir d'un
    <b>commit</b>. Il faut voir les
    <b>commits</b> comme des ronds-points (la route étant
    l'historique de votre projet) à partir desquels vous pouvez, si vous
    le souhaitez, prendre une autre direction dans votre projet.
  </p>
  <p>
    Si vous créez une branche, disons <b>test</b>, alors
    que des modifications de votre espace de travail ne sont pas
    <b>commitées</b> dans votre branche
    <b>master</b>, les modifications que vous effectuerez
    s'appliqueront aux fichiers non <b>commités</b> de
    votre espace de travail. Si vous faites une erreur, vous ne pourrez
    pas retrouver le <b>statu quo ante</b> de vos fichiers
    en revenant à la branche <b>master</b>.
  </p>
  <p>
    Si vous voulez enregistrer votre travail au fil de l'eau afin de
    pouvoir revenir à tout moment à un état antérieur, il vous faut donc
    <b>committer</b> régulièrement et sauvegarder votre
    espace de travail, répertoire <b>.git</b> y compris,
    par exemple <b>via</b> rsync. Lorsque vous déciderez
    de partager votre travail, vous pourrez déplacer, fusionner ou
    supprimer vos <b>commits</b> avant de les envoyer sous
    forme de patchs ou de les déposer sur un dépôt central.
  </p>
  </body>
</topic>
